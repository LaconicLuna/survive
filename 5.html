<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>heat</title>
  <style>
    body {
      background-color: #0e0e0e;
      color: #e0e0e0;
      font-family: monospace;
      padding: 0;
      margin: 0;
      touch-action: none; /* Prevent default touch behavior */
    }

    #canvas {
      width: 100%;
      height: 100%;
      background-color: #0e0e0e;
      display: block;
      position: absolute; 
      top: 0;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const heatConstant = 0.01;
    const maxTouches = 25;
    let touches = [];

    const squares = [];
    const speed = 0.5;

    for (let i = 0; i < canvas.width;) {
      const max = 10;
      for (let j = 0; j < canvas.height;) {
        const height = 10;
        j += height;
        squares.push({
          x: i,
          y: j,
          size: height,
          heat: 0
        });
      }
      i += max;
    }

    function thermalColor(value) {
      value = Math.min(1, Math.max(0, value));
      const stops = [
        { r: 0, g: 0, b: 0 },
        { r: 0, g: 0, b: 255 },
        { r: 0, g: 255, b: 255 },
        { r: 0, g: 255, b: 0 },
        { r: 255, g: 255, b: 0 },
        { r: 255, g: 0, b: 0 },
        { r: 255, g: 255, b: 255 }
      ];

      const scaled = value * (stops.length - 1);
      const i = Math.floor(scaled);
      const t = scaled - i;

      const c1 = stops[i];
      const c2 = stops[i + 1] || c1;

      const r = Math.round(c1.r + t * (c2.r - c1.r));
      const g = Math.round(c1.g + t * (c2.g - c1.g));
      const b = Math.round(c1.b + t * (c2.b - c1.b));

      return `rgb(${r}, ${g}, ${b})`;
    }

    function getDistance(x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function draw() {
      for (let square of squares) {
        // Accumulate heat from all touch points
        for (let t of touches) {
          const distance = getDistance(square.x, square.y, t.x, t.y);
          const falloff = Math.exp(-distance * 0.02);
          square.heat += heatConstant * falloff * 5;
        }

        square.heat *= 0.996; // cooling
        square.heat = Math.max(0, Math.min(1, square.heat));

        ctx.fillStyle = thermalColor(square.heat);
        ctx.fillRect(square.x, square.y, square.size, square.size);
      }

      requestAnimationFrame(draw);
    }

    // Handle mouse for non-touch devices
    canvas.addEventListener("mousemove", (e) => {
      touches = [{ x: e.clientX, y: e.clientY }];
    });

    // Handle touch start
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      touches = Array.from(e.touches).slice(0, maxTouches).map(t => ({
        x: t.clientX,
        y: t.clientY
      }));
    });

    // Handle touch move
    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      touches = Array.from(e.touches).slice(0, maxTouches).map(t => ({
        x: t.clientX,
        y: t.clientY
      }));
    });

    // Handle touch end and cancel
    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      touches = Array.from(e.touches).slice(0, maxTouches).map(t => ({
        x: t.clientX,
        y: t.clientY
      }));
    });

    canvas.addEventListener("touchcancel", (e) => {
      e.preventDefault();
      touches = [];
    });

    draw();
  </script>
</body>
</html>
